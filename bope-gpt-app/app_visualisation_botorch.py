import flask
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import plotly.graph_objs as go
import numpy as np
from flask import request, render_template_string
from flask_cors import CORS
import ast
import json
import numpy as np


import torch
from botorch.models import SingleTaskGP
from botorch.fit import fit_gpytorch_model
from gpytorch.mlls import ExactMarginalLogLikelihood
from botorch.acquisition import qExpectedImprovement
from botorch.optim import optimize_acqf
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.animation import FuncAnimation
import seaborn as sns
import pandas as pd
from botorch.utils.sampling import draw_sobol_samples
from torch.quasirandom import SobolEngine

global best_y_list, itera_list, mean_list,train_x_list, train_y_list
train_x_list = []
train_y_list = []
mean_list = []
best_y_list = []
itera_list = []

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(device)
dtype = torch.float64

bounds = torch.tensor([[0., 0., 0., 0.], [1., 1., 1., 1.]], dtype=dtype, device=device)

# # Define the Branin function with input scaling, i.e, takes between [0,1] x [0,1] instead of the typical [0,15] x [-5,10]
def branin(x, negate=False):
  a = 1.0
  b = 5.1 / (4 * torch.pi**2)
  c = 5 / torch.pi
  d = 6
  e = 10
  f = 1 / (8 * torch.pi)

  x1 = 15 * x[:, 0] - 5
  x2 = 15 * x[:, 1]

  result = a * (x2 - b * x1**2 + c * x1 - d)**2 + e * (1 - f) * torch.cos(x1) + e

  if negate:
    return -result
  else:
    return result

# Constants for the Branin function
a = 1
b = 5.1 / (4*np.pi**2)
c = 5 / np.pi
d = 6
e = 10
f = 1 / (8*np.pi)

# Define the Branin function
def branin_2(x, y):
    return a * (y - b*x**2 + c*x - d)**2 + e*(1-f)*np.cos(x) + e
# Initialize Flask server
server = flask.Flask(__name__)
CORS(server)
print("Flask running in http://127.0.0.1:8080/")
# HTML content to be served by Flask
HTML_CONTENT = '''
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The BOPE-GPT App</title>
<style>
  body {
    font-family: Roboto, sans-serif;
    background: linear-gradient(to right, #74ebd5 0%, #ACB6E5 100%); /* Update for webpage background */
  }
  .container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    width: 80%;
    margin: auto;
    text-align: center;
  }
  .box {
    border: 1px solid #000;
    border-radius: 10px;
    padding: 20px;
    margin: 20px;
    background: linear-gradient(to right, rgba(255, 246, 183, 0.1) 0%, rgba(246, 65, 108, 0.1) 100%); /* Slight change for all boxes */
  }
  .button {
    background-color: #4CAF50; /* Green */
    border: none;
    color: white;
    padding: 12px 28px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 16px;
    margin: 4px 2px;
    cursor: pointer;
  }
  #liveVisualization {
    flex: 3; /* Increases the width of the visualization box */
    height: 600px;
    background-color: #ddd; /* Placeholder color, consider changing or keeping based on design preference */
  }
  .parametersBox {
    flex: 2; /* Decreases the width of the parameters box */
    background: linear-gradient(to bottom, rgba(142, 45, 226, 0.1), rgba(74, 0, 224, 0.1)) /* Special gradient for parameter box */
  }
</style>

</head>
<body>
<div class="container">
  <p>The BOPE-GPT App</p>

  <div class="box" id="liveVisualization">
    <h2>Live Visualisation</h2>
    <iframe id="dashIframe" src="http://127.0.0.1:8080/dash" style="width: 100%; height: 100%; border: none;"></iframe>
  <!-- The live visualization would be dynamically generated by a Dash app -->
 
  </div>

  <div class="box parametersBox">
    <p>Multi-output dataset or model (csv, model weights)</p>
    <input type="file" id="fileInput" accept=".csv, .model">
    <p>Initial prompt setup for the LLM</p>
    <textarea id="promptInput" rows="4" cols="50">Enter initial prompt here...</textarea>
    <div>
      <label for="inputBounds">Number of inputs:</label>
      <input type="text" id="inputBounds" name="inputBounds">
    </div>
    <div>
      <label for="numSamples">Number of initial samples:</label>
      <input type="number" id="numSamples" name="numSamples">
    </div>
    <div>
      <label for="numBatch">Number of samples per batch:</label>
      <input type="number" id="numBatch" name="numBatch">
    </div>
    <div>
      <input type="checkbox" id="flexiblePrompt" name="flexiblePrompt">
      <label for="flexiblePrompt">Enable flexible prompt setup across iterations</label>
    </div>
    <div>
      <input type="checkbox" id="pairwiseComparison" name="pairwiseComparison">
      <label for="pairwiseComparison">Enable pairwise comparison explanation from LLM (longer in time)</label>
    </div>
    <button class="button" onclick="nextIteration()">Next iteration</button>
  </div>

</div>
<script>
let iterationCounter = 0;

function nextIteration() {
  
  let valid = true;

    // Check for non-empty values in text inputs and textareas within the parameters box
    document.querySelectorAll('.parametersBox input[type="text"], .parametersBox textarea').forEach(element => {
        if (!element.value.trim()) {
            alert('Please fill out all text fields.');
            valid = false;
            return;
        }
    });

    // Check if the file input is correct and has a valid file name
    const fileInput = document.getElementById('fileInput');
    if (fileInput.files.length > 0) {
        const fileName = fileInput.files[0].name;
        if (!/\.(csv|pkl)$/i.test(fileName)) {
            alert('Please select a .csv or .pkl file.');
            valid = false;
        }
    } else {
        alert('Please select a file.');
        valid = false;
    }

    if (!valid) {
        return; // Stop the function if validation failed
    }
  
  iterationCounter++; // Increment the counter

  const formData = {
    promptInput: document.getElementById('promptInput').value,
    inputBounds: document.getElementById('inputBounds').value,
    numSamples: document.getElementById('numSamples').value,
    numBatch: document.getElementById('numBatch').value,
    flexiblePrompt: document.getElementById('flexiblePrompt').checked,
    pairwiseComparison: document.getElementById('pairwiseComparison').checked,
    iterationCount: iterationCounter, 
  };

  const jsonString = JSON.stringify(formData);
  // alert(jsonString);

  fetch('/submit-json', {
    method: 'POST',
    headers: {
      'Content-Type': 'text/plain'
    },
    body: jsonString
  })
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.text();
  })
  .then(data => {
    console.log('Response received:', data);
    // Handle response data as needed
  })
  .catch(error => {
    console.error('There was a problem with the fetch operation:', error);
  });

   // Hide multi-output dataset options and initial samples number
  document.getElementById('fileInput').disabled = true;
  document.getElementById('numSamples').closest('div').style.display = 'none'; // Assuming the first instance is the "Number of initial samples"

  // Block number of inputs from being edited
  document.getElementById('inputBounds').disabled = true;

  // Lock the prompt input if flexible prompt is not checked, otherwise unlock it
  if (!document.getElementById('flexiblePrompt').checked) {
    document.getElementById('promptInput').readOnly = true; // Locks the prompt input
  } else {
    document.getElementById('promptInput').readOnly = false; // Unlocks the prompt input
    document.getElementById('promptInput').value = 'Enter prompt for next iteration...'; // Example modification
  }

  // Add download button if not already present
  if (!document.getElementById('downloadButton')) { // Prevent multiple buttons
    var downloadBtn = document.createElement('button');
    downloadBtn.className = 'button';
    downloadBtn.id = 'downloadButton';
    downloadBtn.innerHTML = 'Download Results';
    downloadBtn.onclick = function() {
      alert('Download logic goes here!'); // Placeholder for download functionality
    };
    document.querySelector('.parametersBox').appendChild(downloadBtn);
  }

  // Refresh the Dash iframe to update the visualization
  var dashIframe = document.getElementById('dashIframe');
  var iframeUrl = "http://127.0.0.1:8080/dash"; // Base URL of your Dash app
   dashIframe.src = iframeUrl + "?update=" + new Date().getTime(); // Appending a unique query string to force refresh


  alert("Iteration complete!");
}
</script>
<footer style="text-align:center; margin-top:20px;">
  <p>Developed by the BOPE-GPT team</p>
</body>
</html>
'''
resolution=100
x1 = torch.linspace(bounds[0, 0], bounds[1, 0], resolution, dtype=dtype, device=device)
x2 = torch.linspace(bounds[0, 1], bounds[1, 1], resolution, dtype=dtype, device=device)
X1, X2 = torch.meshgrid(x1, x2)
X1_num=X1.cpu().numpy()
X2_num=X2.cpu().numpy()

def botorch_process(d):
  global train_x_list, train_y_list, best_y_list, itera_list, mean
  dim=int(d["inputBounds"])
  N=int(d["numSamples"])
  batch_size=int(d["numBatch"])
  itera=int(d["iterationCount"])
  print(dim,N,batch_size,itera)
  if itera==1:
    sobol_engine = SobolEngine(dimension=dim, scramble=False)  # 2 dimensions for your input space
    train_x = draw_sobol_samples(bounds=bounds, n=1, q=N).squeeze(0)
    train_y=branin(train_x, negate=True).unsqueeze(-1)
    train_x_list.append(train_x)
    train_y_list.append(train_y)
  train_x=train_x_list[-1]
  train_y=train_y_list[-1]
  print(train_x,train_y)
  best_y=train_y.max().cpu().numpy()

  best_y_list.append(best_y)
  itera_list.append(itera)
    
  gp_model = SingleTaskGP(train_x, train_y).to(device=device, dtype=dtype)
  mll = ExactMarginalLogLikelihood(gp_model.likelihood, gp_model)
  fit_gpytorch_model(mll)

  
  EI = qExpectedImprovement(model=gp_model, best_f=train_y.max())#, maximize=True)
  #optimisation of acquisition function
  candidate, _ = optimize_acqf(
        acq_function=EI,
        bounds=bounds,
        q=batch_size,
        num_restarts=5,
        raw_samples=20,
        options={"dtype": dtype, "device": device}
    )
    
  new_y = branin(candidate, negate=True).unsqueeze(-1)
  print(new_y)
  train_x = torch.cat([train_x, candidate])
  train_y = torch.cat([train_y, new_y])
  train_x_list.append(train_x)
  train_y_list.append(train_y)

  resolution=100
  grid = torch.stack([X1.flatten(), X2.flatten()], -1)
  with torch.no_grad():
    mean = gp_model.posterior(grid).mean.cpu().numpy().reshape(resolution, resolution)
    mean_list.append(mean)


  return None

# Serve the HTML page at the root
@server.route('/')
def index():
    return render_template_string(HTML_CONTENT)

# Initialize the Dash app
app = dash.Dash(__name__, server=server, routes_pathname_prefix='/dash/')

app.layout = html.Div([
    html.Div([
        dcc.Graph(id='branin-contour-plot-graph'),
    ], style={'width': '50%', 'display': 'inline-block'}),
    html.Div([
        dcc.Graph(id='branin-surface-plot-graph'),
    ], style={'width': '50%', 'display': 'inline-block'}),
    dcc.Interval(
    id="load_interval", 
    n_intervals=0, 
    max_intervals=0, #<-- only run once
    interval=1
),
html.Span(
    id="spanner",
    style=dict(color="yellow") #<-- just so it's easy to see
),
])
# Callback for the contour plot
@app.callback(
    Output('branin-contour-plot-graph', 'figure'),
    [Input(component_id="load_interval", component_property="n_intervals"),]
)
def update_contour_plot(load_interval):
    #print(train_x_list)
    figure = go.Figure(data=go.Contour(z=mean_list, x=X1_num, y=X2_num))
    figure.update_xaxes(range=[0, 1])  # Here, 0 is the minimum and 6 is the maximum value for x-axis
    figure.update_yaxes(range=[0, 1])
    figure.update_layout(title='Branin Function Contour Plot',
                         xaxis_title='X',
                         yaxis_title='Y')
    return figure

# Callback for the 3D surface plot
@app.callback(
    Output('branin-surface-plot-graph', 'figure'),
    [Input(component_id="load_interval", component_property="n_intervals"),]
)
def update_surface_plot(load_interval):
    figure = go.Figure(data=go.Scatter(x=itera_list, y=best_y_list, mode='lines+markers'))

    figure.update_layout(title='Best value',
                         scene=dict(xaxis_title='X', yaxis_title='Y', zaxis_title='Z'),
                         autosize=True)
    return figure

@server.route('/submit-json', methods=['POST'])
def process_data():
    # Access the raw data from the POST request
    raw_data = request.get_data(as_text=True)  # or use request.data for binary data
    print(raw_data)
    d = json.loads(raw_data)
    botorch_process(d)
    return d


# Run the app
if __name__ == '__main__':
    app.run_server(debug=True, host="127.0.0.1", port=8080)

