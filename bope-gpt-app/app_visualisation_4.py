import flask
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import plotly.graph_objs as go
import numpy as np
from flask import request, render_template_string
from flask_cors import CORS
import ast
import json
# Initialize Flask server
server = flask.Flask(__name__)
CORS(server)
print("Flask running in http://127.0.0.1:8080/")
# HTML content to be served by Flask
HTML_CONTENT = '''
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The BOPE-GPT App</title>
<style>
  body {
    font-family: Roboto, sans-serif;
    background: linear-gradient(to right, #74ebd5 0%, #ACB6E5 100%); /* Update for webpage background */
  }
  .container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    width: 80%;
    margin: auto;
    text-align: center;
  }
  .box {
    border: 1px solid #000;
    border-radius: 10px;
    padding: 20px;
    margin: 20px;
    background: linear-gradient(to right, rgba(255, 246, 183, 0.1) 0%, rgba(246, 65, 108, 0.1) 100%); /* Slight change for all boxes */
  }
  .button {
    background-color: #4CAF50; /* Green */
    border: none;
    color: white;
    padding: 12px 28px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 16px;
    margin: 4px 2px;
    cursor: pointer;
  }
  #liveVisualization {
    flex: 3; /* Increases the width of the visualization box */
    height: 600px;
    background-color: #ddd; /* Placeholder color, consider changing or keeping based on design preference */
  }
  .parametersBox {
    flex: 2; /* Decreases the width of the parameters box */
    background: linear-gradient(to bottom, rgba(142, 45, 226, 0.1), rgba(74, 0, 224, 0.1)) /* Special gradient for parameter box */
  }
</style>

</head>
<body>
<div class="container">
  <p>The BOPE-GPT App</p>

  <div class="box" id="liveVisualization">
    <h2>Live Visualisation</h2>
    <iframe id="dashIframe" src="http://127.0.0.1:8080/dash" style="width: 100%; height: 100%; border: none;"></iframe>
  <!-- The live visualization would be dynamically generated by a Dash app -->
 
  </div>

  <div class="box parametersBox">
    <p>Multi-output dataset or model (csv, model weights)</p>
    <input type="file" id="fileInput" accept=".csv, .model">
    <p>Initial prompt setup for the LLM</p>
    <textarea id="promptInput" rows="4" cols="50">Enter initial prompt here...</textarea>
    <div>
      <label for="inputBounds">Number of inputs:</label>
      <input type="text" id="inputBounds" name="inputBounds">
    </div>
    <div>
      <label for="numSamples">Number of initial samples:</label>
      <input type="number" id="numSamples" name="numSamples">
    </div>
    <div>
      <label for="numSamples">Number of samples per batch:</label>
      <input type="number" id="numSamples" name="numSamples">
    </div>
    <div>
      <input type="checkbox" id="flexiblePrompt" name="flexiblePrompt">
      <label for="flexiblePrompt">Enable flexible prompt setup across iterations</label>
    </div>
    <div>
      <input type="checkbox" id="pairwiseComparison" name="pairwiseComparison">
      <label for="pairwiseComparison">Enable pairwise comparison explanation from LLM (longer in time)</label>
    </div>
    <button class="button" onclick="nextIteration()">Next iteration</button>
  </div>

</div>
<script>
function nextIteration() {

  let valid = true;

    // Check for non-empty values in text inputs and textareas within the parameters box
    document.querySelectorAll('.parametersBox input[type="text"], .parametersBox textarea').forEach(element => {
        if (!element.value.trim()) {
            alert('Please fill out all text fields.');
            valid = false;
            return;
        }
    });

    // Check if the file input is correct and has a valid file name
    const fileInput = document.getElementById('fileInput');
    if (fileInput.files.length > 0) {
        const fileName = fileInput.files[0].name;
        if (!/\.(csv|pkl)$/i.test(fileName)) {
            alert('Please select a .csv or .pkl file.');
            valid = false;
        }
    } else {
        alert('Please select a file.');
        valid = false;
    }

    if (!valid) {
        return; // Stop the function if validation failed
    }

  const formData = {
    promptInput: document.getElementById('promptInput').value,
    inputBounds: document.getElementById('inputBounds').value,
    numSamples: document.getElementById('numSamples').value,
    flexiblePrompt: document.getElementById('flexiblePrompt').checked,
    pairwiseComparison: document.getElementById('pairwiseComparison').checked
  };

  const jsonString = JSON.stringify(formData);
  // alert(jsonString);

  fetch('/submit-json', {
    method: 'POST',
    headers: {
      'Content-Type': 'text/plain'
    },
    body: jsonString
  })
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.text();
  })
  .then(data => {
    console.log('Response received:', data);
    // Handle response data as needed
  })
  .catch(error => {
    console.error('There was a problem with the fetch operation:', error);
  });

   // Hide multi-output dataset options and initial samples number
  document.getElementById('fileInput').disabled = true;
  document.getElementById('numSamples').closest('div').style.display = 'none'; // Assuming the first instance is the "Number of initial samples"

  // Block number of inputs from being edited
  document.getElementById('inputBounds').disabled = true;

  // Lock the prompt input if flexible prompt is not checked, otherwise unlock it
  if (!document.getElementById('flexiblePrompt').checked) {
    document.getElementById('promptInput').readOnly = true; // Locks the prompt input
  } else {
    document.getElementById('promptInput').readOnly = false; // Unlocks the prompt input
    document.getElementById('promptInput').value = 'Enter prompt for next iteration...'; // Example modification
  }

  // Add download button if not already present
  if (!document.getElementById('downloadButton')) { // Prevent multiple buttons
    var downloadBtn = document.createElement('button');
    downloadBtn.className = 'button';
    downloadBtn.id = 'downloadButton';
    downloadBtn.innerHTML = 'Download Results';
    downloadBtn.onclick = function() {
      alert('Download logic goes here!'); // Placeholder for download functionality
    };
    document.querySelector('.parametersBox').appendChild(downloadBtn);
  }

  // Refresh the Dash iframe to update the visualization
  var dashIframe = document.getElementById('dashIframe');
  var iframeUrl = "http://127.0.0.1:8080/dash"; // Base URL of your Dash app
   dashIframe.src = iframeUrl + "?update=" + new Date().getTime(); // Appending a unique query string to force refresh


  alert("Iteration complete!");
}
</script>
<footer style="text-align:center; margin-top:20px;">
  <p>Developed by the BOPE-GPT team</p>
</body>
</html>
'''

# Serve the HTML page at the root
@server.route('/')
def index():
    return render_template_string(HTML_CONTENT)

# Initialize the Dash app
app = dash.Dash(__name__, server=server, routes_pathname_prefix='/dash/')

# App layout (as before)
app.layout = html.Div([
    dcc.Graph(id='sine-wave-graph'),
    html.Label('Frequency:'),
    dcc.Slider(
        id='frequency-slider',
        min=1,
        max=10,
        value=2,
        marks={i: str(i) for i in range(1, 11)},
        step=0.1,
    ),
])

# Callback to update the graph based on the slider input (as before)
@app.callback(
    Output('sine-wave-graph', 'figure'),
    [Input('frequency-slider', 'value')]
)
def update_graph(frequency):
    x_values = np.linspace(0, 10, 500)
    y_values = np.sin(frequency * x_values)
    figure = {
        'data': [go.Scatter(x=x_values, y=y_values, mode='lines')],
        'layout': go.Layout(
            title='Dynamic Sine Wave',
            xaxis={'title': 'X Value'},
            yaxis={'title': 'Sin(X)'},
        ),
    }
    return figure


@server.route('/submit-json', methods=['POST'])
def process_data():
    # Access the raw data from the POST request
    raw_data = request.get_data(as_text=True)  # or use request.data for binary data
    print(raw_data)
    d = json.loads(raw_data)
    print(d)
    #print(raw_data)
    return d


# Run the app
if __name__ == '__main__':
    app.run_server(debug=True, host="127.0.0.1", port=8080)

